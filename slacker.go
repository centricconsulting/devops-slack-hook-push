package main

import (
	"bytes"
	"encoding/json"
	"github.com/go-martini/martini"
	"log"
	"net/http"
	"os"
	"strconv"
)

var (
	slackerFile string
	slackers    map[string]SlackConfig
)

type SlackConfig struct {
	Key               string       `json:"key"`                 // reqd
	UseTelemetri      bool         `json:"use_telemetri"`       // future, defaults false
	MessageTemplateId string       `json:"message_template_id"` // future
	Action            string       `json:"action"`              // Success, Error, Warning, Info
	IsActive          bool         `json:"is_active"`           // future, defaults true
	Hook              string       `json:"hook"`                // reqd
	IsSystem          bool         `json:"is_system"`           // future, defaults false
	ErrorChannel      string       `json:"error_channel"`       // If populated, errors get sent here
	SlackData         SlackMessage `json:"slack_data"`
}

type SlackMessage struct {
	UserName  string `json:"username"`   // Overrides username assigned to hook
	IconURL   string `json:"icon_url"`   // Overrides icon assigned to hook
	IconEmoji string `json:"icon_emoji"` // Overrides emoji assigned to hook
	Channel   string `json:"channel"`    // "#other-channel; @username"
	Text      string `json:"text"`       // more for outbound use, may be used as canned text later
}

// AddSlacker will validate a new configuration record, then add it to the in-memory
// map which will then be persisted to disk.
func AddSlacker(sc SlackConfig) (int, string) {
	// Verify the data is good enough to all passage.
	if !ValidateRequest(sc.Key) {
		return http.StatusBadRequest, "UUID is invalid."
	}
	// Make sure the uuid does not already exist.
	if slackers[sc.Key].Key != "" {
		return http.StatusBadRequest, "UUID already exists."
	}
	// We also need a hook generated by Slack.  Otherwise they won't know where to send it.
	if sc.Hook == "" {
		return http.StatusBadRequest, "You need a Slack hook to receive the messages."
	}

	// Everything looks good, add the item to the slacker map.  Then delete the request
    // record from the map.
	slackers[sc.Key] = sc
    DeleteRequest(sc.Key)

	return http.StatusOK, "New config record added."
} // func

// DeleteSlacker will delete the specified slacker key from the map.  The map is what
// drives the slacker file so on the next write operation, the slacker file will
// simply persist without the deleted key.
func DeleteSlacker(params martini.Params) (int, string) {
	delete(slackers, params["key_id"])
	return http.StatusOK, "Slacker record deleted."
} // func

// GetSlacker retrieves the slacker structure based on the provided Id.
func GetSlacker(id string) SlackConfig {
	slacker := slackers[id]
	return slacker
} // func

// GetSlackerCount returns the current number of slacker structs being served.
func GetSlackerCount() (int, string) {
	return http.StatusOK, strconv.Itoa(len(slackers))
} // func

// FlushSlackers will write all of the configurations to disk.
func FlushSlackers() {
	file, err := os.Create(slackerFile)
	if err != nil {
		log.Printf("error: Unable to open file/%s", err.Error())
	}
	defer file.Close()

	// Let's make the JSON pretty.
	buf, err := json.MarshalIndent(slackers, "", "  ")
	if err != nil {
		log.Printf("error: Unable to encode JSON file/%s", err.Error())
	}

	// Now output the lot.
	out := bytes.NewBuffer(buf)
	_, err = out.WriteTo(file)
	if err != nil {
		log.Printf("error: Could not write to buffer/%s", err.Error())
	} else {
		log.Printf("info: Saved %d Slackers to disk.", len(slackers))
	}
} // func

// LoadSlackers makes sure the string sent in with the request is valid.  This
// hopefully keeps people from messing with it randomly.
func LoadSlackers() bool {
	// Check credentials to make sure this is a legit request.
	file, err := os.Open(slackerFile)
	// If there is a problem with the file, err on the side of caution and
	// reject the request.
	if err != nil {
		log.Printf("error: Unable to open file/%s", err.Error())
		return false
	}
	defer file.Close()

	// Allocate memory for the map.  We use this map to lookup configurations
	// when sending out Slack posts.
	slackers = make(map[string]SlackConfig)

	// Decode the json into something we can process.  The JSON is set up to load
	// into a map.  We could also do an array and move it to a map, but why?
	decoder := json.NewDecoder(file)
	err = decoder.Decode(&slackers)
	if err != nil {
		log.Printf("error: Could not decode Slackers JSON/%s", err.Error())
		return false
	}
	log.Printf("info: Loaded %d Slackers from disk.", len(slackers))

	// Everything was cool, but the supplied key simply doesn't match anything.
	return false
} // func

// UpdateSlacker will validate the changes to the record, then updates in-memory
// map which will then be persisted to disk.
func UpdateSlacker(sc SlackConfig) (int, string) {
	// Make sure the uuid does not already exist.
	if !ValidateSlacker(sc.Key) {
		return http.StatusBadRequest, "Slacker does not exist."
	}

	// We also need a hook generated by Slack.  Otherwise they won't know where to send it.
	if sc.Hook == "" {
		return http.StatusBadRequest, "You need a Slack hook to receive the messages."
	}

	// Everything looks good, update the item to the slacker map.
	slackers[sc.Key] = sc

	return http.StatusOK, "Config record updated."
} // func

// ValidateSlacker will make sure the slacker record actually exists.
func ValidateSlacker(id string) bool {
	if slackers[id].Key == "" {
		return false
	}
	return true
} // func
